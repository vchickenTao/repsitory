## <span id="Java并发—理论基础">**Java并发—理论基础**</span>

### 为什么需要多线程

众所周知，`CPU`、`内存`、`I/O` 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，`计算机体系结构`、`操作系统`、`编译程序`都做出了贡献，主要体现为:

- CPU 增加了缓存，以均衡与内存的速度差异；导致 `可见性`问题
- 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；导致 `原子性`问题
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。导致 `有序性`问题



### 线程不安全示例

如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。

以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。

```java
/**
 * @Description ThreadUnsafeExample
 * @Author vchicken
 * @Date 2022/9/2 15:48
 */
public class ThreadUnsafeExample {

    private int cnt = 0;

    public void add() {
        cnt++;
    }

    public int get() {
        return cnt;
    }

    public static void main(String[] args) throws InterruptedException {
        final int threadSize = 1000;
        ThreadUnsafeExample example = new ThreadUnsafeExample();
        final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < threadSize; i++) {
            executorService.execute(() -> {
                example.add();
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        System.out.println(example.get());
    }
}
```

```html
989 // 结果总是小于1000
```



### 并发出现问题的根源: 并发三要素

上述代码输出为什么不是1000? 并发出现问题的根源是什么?

#### 可见性: CPU缓存引起

可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。

举个简单的例子，看下面这段代码：

```java
//线程1执行的代码
int i = 0;
i = 10;
 
//线程2执行的代码
j = i; 
```

假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。

此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.

这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。

#### 原子性: 分时复用引起

原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

举个简单的例子，看下面这段代码：

```java
int i = 1;

// 线程1执行
i += 1;

// 线程2执行
i += 1;
```

这里需要注意的是：`i += 1`需要三条 CPU 指令

1. 将变量 i 从内存读取到 CPU寄存器；
2. 在CPU寄存器中执行 i + 1 操作；
3. 将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。

由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。

#### 有序性: 重排序引起

有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：

```java
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
```

上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：

![指令重排序](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/1b2cd34f-a3c7-4901-a713-f657b14870ab.png)


上述的 1 属于**编译器重排序**，2 和 3 属于**处理器重排序**。这些重排序都可能会导致多线程程序出现内存可见性问题。

- 对于编译器重排序，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。
- 对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

具体可以参看：[Java 内存模型详解]()的重排序章节。

### JAVA是怎么解决并发问题的: JMM(Java内存模型)

Java 内存模型是个很复杂的规范，强烈推荐你看后续（应该是网上能找到最好的材料之一了）：[Java 内存模型详解]()。

**理解的第一个维度：核心知识点**

JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：

- volatile、synchronized 和 final 三个关键字
- Happens-Before 规则

**理解的第二个维度：可见性，有序性，原子性**

- 原子性

在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作：

```java
x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中
y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
x = x + 1;     //语句4： 同语句3
```

上面4个语句只有语句1的操作具备原子性。

也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。

> 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

- 可见性

Java提供了volatile关键字来保证可见性。

当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

> 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

- 有序性

在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。

关键字: volatile、synchronized 和 final

以下三篇文章详细分析了这三个关键字：

- [关键字: synchronized详解]()
- [关键字: volatile详解]()
- [关键字: final详解]()

Happens-Before 规则

上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。

1. 单一线程原则

> Single Thread rule

在一个线程内，在程序前面的操作先行发生于后面的操作。

![Single Thread rule](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/ef7fe59b-6690-4640-92f1-219b8a3644e3.png)

2. 管程锁定规则

> Monitor Lock Rule

一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

![Monitor Lock Rule](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/a980f786-0186-45de-8524-bf9b1c49384c.png)

3. volatile 变量规则

> Volatile Variable Rule

对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

![Volatile Variable Rule](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/4181b180-ff34-48f5-907b-accacbf5b6d7.png)

4. 线程启动规则

> Thread Start Rule

Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。

![image](https://pdai.tech/_images/pics/thread-start-rule.png)

5. 线程加入规则

> Thread Join Rule

Thread 对象的结束先行发生于 join() 方法返回。

![Thread Join Rule](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/b2da3f51-c944-4602-8f39-697ac2fe4069.png)

6. 线程中断规则

> Thread Interruption Rule

对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。

7. 对象终结规则

> Finalizer Rule

一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。

8. 传递性

> Transitivity

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

### 线程安全: 不是一个非真即假的命题

一个类在可以被多个线程安全调用时就是线程安全的。

线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

#### 1. 不可变

不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。

多线程环境下，应当尽量使对象成为不可变，来满足线程安全。

不可变的类型:

- final 关键字修饰的基本数据类型
- String
- 枚举类型
- Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。

对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。

```java
public class ImmutableExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        Map<String, Integer> unmodifiableMap = Collections.unmodifiableMap(map);
        unmodifiableMap.put("a", 1);
    }
} 
```

```html
Exception in thread "main" java.lang.UnsupportedOperationException
    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
    at ImmutableExample.main(ImmutableExample.java:9)
```

Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。

```java
public V put(K key, V value) {
    throw new UnsupportedOperationException();
}
```

#### 2. 绝对线程安全

不管运行时环境如何，调用者都不需要任何额外的同步措施。

#### 3. 相对线程安全

相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。

对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。

```java
public class VectorUnsafeExample {
    private static Vector<Integer> vector = new Vector<>();

    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i < 100; i++) {
                vector.add(i);
            }
            ExecutorService executorService = Executors.newCachedThreadPool();
            executorService.execute(() -> {
                for (int i = 0; i < vector.size(); i++) {
                    vector.remove(i);
                }
            });
            executorService.execute(() -> {
                for (int i = 0; i < vector.size(); i++) {
                    vector.get(i);
                }
            });
            executorService.shutdown();
        }
    }
} 
```

```html
Exception in thread "Thread-159738" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 3
    at java.util.Vector.remove(Vector.java:831)
    at VectorUnsafeExample.lambda$main$0(VectorUnsafeExample.java:14)
    at VectorUnsafeExample$$Lambda$1/713338599.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:745)
```

如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。

```java
executorService.execute(() -> {
    synchronized (vector) {
        for (int i = 0; i < vector.size(); i++) {
            vector.remove(i);
        }
    }
});
executorService.execute(() -> {
    synchronized (vector) {
        for (int i = 0; i < vector.size(); i++) {
            vector.get(i);
        }
    }
}); 
```

#### 4. 线程兼容

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。

#### 5. 线程对立

线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。

### 线程安全的实现方法

####  1. 互斥同步

synchronized 和 ReentrantLock。

初步了解你可以看：

- [Java 并发 - 线程基础：线程互斥同步]()

详细分析请看：

- [关键字: Synchronized详解]()
- [JUC锁: ReentrantLock详解]()

#### 2. 非阻塞同步

互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。

互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

**(一)CAS**

随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。

乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。

**(二)AtomicInteger**

J.U.C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。

以下代码使用了 AtomicInteger 执行了自增的操作。

```java
private AtomicInteger cnt = new AtomicInteger();

public void add() {
    cnt.incrementAndGet();
}    
```

以下代码是 incrementAndGet() 的源码，它调用了 unsafe 的 getAndAddInt() 。

```java
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
} 
```

以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。

可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
} 
```

**(三)ABA**

如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。

J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。

CAS, Unsafe和原子类详细分析请看：

- [JUC原子类: CAS, Unsafe和原子类详解]()

#### 3. 无同步方案

要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。

**(一)栈封闭**

多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class StackClosedExample {
    public void add100() {
        int cnt = 0;
        for (int i = 0; i < 100; i++) {
            cnt++;
        }
        System.out.println(cnt);
    }
}  
```

```java
public static void main(String[] args) {
    StackClosedExample example = new StackClosedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> example.add100());
    executorService.execute(() -> example.add100());
    executorService.shutdown();
}
```

```html
100
100
```

更详细的分析请看J.U.C中线程池相关内容详解：

- [JUC线程池: FutureTask详解]()
- [JUC线程池: ThreadPoolExecutor详解]()
- [JUC线程池: ScheduledThreadPool详解]()
- [JUC线程池: Fork/Join框架详解]()

**(二)线程本地存储(Thread Local Storage)**

如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。

可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。

对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。

```java
public class ThreadLocalExample {
    public static void main(String[] args) {
        ThreadLocal threadLocal = new ThreadLocal();
        Thread thread1 = new Thread(() -> {
            threadLocal.set(1);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(threadLocal.get());
            threadLocal.remove();
        });
        Thread thread2 = new Thread(() -> {
            threadLocal.set(2);
            threadLocal.remove();
        });
        thread1.start();
        thread2.start();
    }
}  
```

输出结果

```html
1
```

为了理解 ThreadLocal，先看以下代码:

```java
public class ThreadLocalExample1 {
    public static void main(String[] args) {
        ThreadLocal threadLocal1 = new ThreadLocal();
        ThreadLocal threadLocal2 = new ThreadLocal();
        Thread thread1 = new Thread(() -> {
            threadLocal1.set(1);
            threadLocal2.set(1);
        });
        Thread thread2 = new Thread(() -> {
            threadLocal1.set(2);
            threadLocal2.set(2);
        });
        thread1.start();
        thread2.start();
    }
}  
```

它所对应的底层结构图为:

![ThreadLocal底层结构图](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/1fd4f6d2-60b2-4f1c-bcf2-3f93c1b7501a.png)

每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象，Thread 类中就定义了 ThreadLocal.ThreadLocalMap 成员。

```java
/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;    
```

当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal->value 键值对插入到该 Map 中。

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

get() 方法类似。

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。

在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。

更详细的分析看：[Java 并发 - ThreadLocal详解]()

**(三)可重入代码(Reentrant Code)**

这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。

可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

## **Java并发—多线程基础**

### 1.任务

  生活中的例子、边吃饭、边玩手机

![](https://img-blog.csdnimg.cn/e25453f8bf4d4475898be82b4613a955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)



  开车、打电话、挂点滴

![](https://img-blog.csdnimg.cn/07b0dfac109a44b0b910ee30165c9d3c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

  上厕所、玩手机

![](https://img-blog.csdnimg.cn/e9c22693b74e42acb2123f5566df3dd8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

  现实中太多这样同时做多件事情的例子了，看起来是多个任务都在做，其实本质上我们的大脑在同一时间依旧只做了一件事情。

![](https://img-blog.csdnimg.cn/712a20b422df4dbaa66746e1cca2568f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

### 2.进程

  在操作系统中运行的程序就是进程，比如你的QQ、播放器、游戏、IDE等等。。。

![](https://img-blog.csdnimg.cn/a775677efe834afab5d6c60e8a5d12e1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

 

一个进程可以有多个线程，如视频中同时听声音，看图像，看弹幕，等等

  1.说起进程，就不得不说下程序。程序是**指令和数据的有序集合**，其本身没有任何运行的含义，是一个静态的概念。

  2.而进程是执行程序的一次执行过程，它是动态的概念。是系统资源分配的单位

  3.通常在一个进程中可以包含若干个线程，当然一个进程至少有一个线程，不然没有存在的意义。**线程是CPU调度和执行的单位**。

注意：很多 多线程是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一时间点，cpu 只能执行一个代码，因为切换的很快，所以有同时执行的错觉。

总结：

  1.**线程就是独立的执行路径**;

  2.在程序运行时，即使没有自己创建线程，后台也会有多个线程，如**主线程，gc线程**;

  3.**main()称之为主线程**，为系统的入口，用于执行整个程序;

  4.在一个进程中，如果开辟了多个线程，**线程的运行由调度器（CPU）安排调度**，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的。

  5.对同一份资源操作时，会存在资源抢夺的问题，需要加入**并发控制**。

  6.线程会带来额外的开销，如**cpu调度时间**，并发控制开销。

  7.每个线程在自己的工作内存交互，内存控制不当会造成数据不一致;

### 3.多线程

  原来是一条路，慢慢因为车太多了，道路堵塞，效率极低。
  为了提高使用的频率，能够充分利用道路，于是加了多个车道。

![](https://img-blog.csdnimg.cn/ebd2ab5246fb4aaaa9ee0caaeada7bd1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

原来的方法调用

![](https://img-blog.csdnimg.cn/89ff4bd5df5a4bea8b7282888a1895d4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)



多线程下的方法调用

![](https://img-blog.csdnimg.cn/bceeca5dd11340868b764545dcffef56.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)



**线程实现三种方式**

   1.继承Thread类

   2.实现Runnable 接口

   3.实现Callable 接口

**继承Thread类实现多线程步骤如下：**

  1. 自定义线程类继承Thread类

     

  2. 重写run() 方法，编写线程执行体

     

  3. 创建线程对象，调用start() 方法启动线程



**创建线程方式1**：继承Thread（通过查看源码发现Thread 是实现Runnable接口的）

注意：线程开启不一定立即执行，由CPU调度安排。

```java
public class TestThread1 extends Thread{

    @Override
    public void run() {
        //run方法 线程体
        for (int i = 0; i < 10; i++) {
            System.out.println("我在看代码--"+i);
        }
    }

    public static void main(String[] args) {
        //创建线程对象
        TestThread1 testThread1 = new TestThread1();
        //调用start()方法 ，开启线程
        testThread1.start();

        //main线程，主线程
        for (int i = 0; i < 10; i++) {
            System.out.println("我在学习多线程--"+i);
        }

    }
}

//执行结果
我在学习多线程--0
我在学习多线程--1
我在学习多线程--2
我在学习多线程--3
我在看代码--0
我在学习多线程--4
我在学习多线程--5
我在学习多线程--6
我在看代码--1
我在学习多线程--7
我在看代码--2
我在看代码--3
我在看代码--4
我在看代码--5
我在看代码--6
我在看代码--7
我在看代码--8
我在看代码--9
我在学习多线程--8
我在学习多线程--9
```

案例：实现多线程同步下载图片

```java
public class TestThread2 extends Thread {

    /**
     * 网络图片地址
     */
    private String url;

    /**
     * 保存的文件名
     */
    private String name;

    public TestThread2(String url, String name) {
        this.name = name;
        this.url = url;
    }

    @Override
    public void run() {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downLoader(url, name);
        System.out.println("下载了文件名为：" + name);
    }


    //下载器
    class WebDownloader {
        public void downLoader(String url, String name) {
            try {
                FileUtils.copyURLToFile(new URL(url), new File(name));
            } catch (IOException e) {
                e.printStackTrace();
                System.out.println("IO 异常，Downloader方法出现问题");
            }
        }
    }

    public static void main(String[] args) {
        TestThread2 thread1 = new TestThread2("https://img-blog.csdnimg.cn/ebd2ab5246fb4aaaa9ee0caaeada7bd1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center", "1.jpg");
        TestThread2 thread2 = new TestThread2("https://img-blog.csdnimg.cn/8dbd178f0ae04e169b20fff6d3d20786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center", "2.jpg");
        TestThread2 thread3 = new TestThread2("https://img-blog.csdnimg.cn/712a20b422df4dbaa66746e1cca2568f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center", "3.jpg");
        //先下载t1
        thread1.start();
        //先下载t2
        thread2.start();
        //先下载t3
        thread3.start();
    }

}

//执行结果
下载了文件名为：2.jpg
下载了文件名为：3.jpg
下载了文件名为：1.jpg
```

**创建线程方式2：实现Runnable接口**

```java
/**
 * @Description TestThread3
 * @Author vchicken
 * @Date 2022/8/29 20:45
 */
public class TestThread3 implements Runnable {

    @Override
    public void run() {
        //run方法 线程体
        for (int i = 0; i < 10; i++) {
            System.out.println("我在看代码--"+i);
        }
    }

    public static void main(String[] args) {
        //创建runnable接口的实现类对象
        TestThread3 testThread3 = new TestThread3();
        //创建线程对象，通过线程对象来开启我们的线程
        Thread thread = new Thread(testThread3);
        thread.start();

        //main线程，主线程
        for (int i = 0; i < 10; i++) {
            System.out.println("我在学习多线程--"+i);
        }

    }
}
```

**Thread 和Runnable小结**

- 继承Thread类

    

  1. 子类继承Thread 类具有多线程能力
  2. 启动线程：子类对象.start()
  3. 不建议使用：避免OOP单继承局限性

  

- 实现Runnable 接口



    1.  实现接口Runnable 具有多线程能力
    2.  启动线程：传入目标对象+Thread对象.start（）
    3.  推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用



**实现接口 VS 继承**
Thread 实现接口会更好一些，因为: 

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口； 
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。

**案例：龟兔赛跑**

​	   1.首先来个赛道距离，然后要离终点越来越近

  2.判断比赛是否结束

  3.打印出胜利者

  4.龟兔赛跑开始

  5.故事中是乌龟赢了，兔子需要睡觉，所以我们模拟兔子睡觉

  6.终于，乌龟赢了

```java
public class Race implements Runnable {

    /**
     * 胜利者
     */
    private static String winner;

    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            //模拟兔子休息
            if (Thread.currentThread().getName().equals("兔子") || i % 10 == 0) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            //判断比赛是否结束
            boolean flag = gameOver(i);
            //如果比赛结束了，就停止程序
            if (flag) {
                break;
            }

            System.out.println(Thread.currentThread().getName() + "-->跑了" + i + "步");
        }
    }

    //判断是否完成比赛
    private boolean gameOver(int steps) {
        if (winner != null) {//已经由胜利者了
            return true;
        } else {
            if (steps >= 100) {
                winner = Thread.currentThread().getName();
                System.out.println("Winner is " + winner);
                return true;
            }

        }
        return false;
    }

    public static void main(String[] args) {

        Race race = new Race();
        new Thread(race, "乌龟").start();
        new Thread(race, "兔子").start();
    }
}
```

**创建线程方式3：实现Callable 接口**

  1.实现Callable接口，需要返回值类型

  2.重写call 方法，需要抛出异常

  3.创建目标对象

  4.创建执行服务：

  5.提交执行：

  6.获取结果：

  7.关闭服务：

```java
/**
 * @Description TestCallable
 * @Author vchicken
 * @Date 2022/8/29 21:25
 */
public class TestCallable implements Callable<Boolean> {

    /**
     * 网络图片地址
     */
    private String url;

    /**
     * 保存的文件名
     */
    private String name;

    public TestCallable(String url, String name) {
        this.name = name;
        this.url = url;
    }

    //下载图片线程的执行体
    @Override
    public Boolean call() throws Exception {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downLoader(url, name);
        System.out.println("下载了文件名为：" + name);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {

        TestCallable thread1 = new TestCallable("https://img-blog.csdnimg.cn/ebd2ab5246fb4aaaa9ee0caaeada7bd1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center", "1.jpg");
        TestCallable thread2 = new TestCallable("https://img-blog.csdnimg.cn/8dbd178f0ae04e169b20fff6d3d20786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center", "2.jpg");
        TestCallable thread3 = new TestCallable("https://img-blog.csdnimg.cn/712a20b422df4dbaa66746e1cca2568f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center", "3.jpg");

        //1.创建执行服务
        ExecutorService ser = Executors.newFixedThreadPool(3);
        //2.提交执行
        Future<Boolean> r1 = ser.submit(thread1);
        Future<Boolean> r2 = ser.submit(thread2);
        Future<Boolean> r3 = ser.submit(thread3);
        //获取结果
        Boolean rs1 = r1.get();
        Boolean rs2 = r2.get();
        Boolean rs3 = r3.get();

        //关闭服务
        ser.shutdownNow();

    }
}

class WebDownloader {
    public void downLoader(String url, String name) {
        try {
            FileUtils.copyURLToFile(new URL(url), new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO 异常，Downloader方法出现问题");
        }
    }
}
```

**优点：**

1. 可以定义返回值
2. 可以抛出异常

### 4.静态代理

![](https://img-blog.csdnimg.cn/309b623abeee47c19011672635c13357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

**静态代理总结：**

  1. 真实对象和代理对象都要实现同一个接口

     

  2. 代理对象要代理真实角色

**好处：**



- 代理对象可以做很多对象做不了的事情

- 真实对象专注做自己的事情

```java
/**
 * @Description StaticProxy
 * @Author vchicken
 * @Date 2022/8/30 19:16
 */
public class StaticProxy {

    public static void main(String[] args) {
        //你要结婚
        You you = new You();

        new Thread(() -> System.out.println("哟西")).start();

        new WeddingCompany(new You()).HappyMarry();
    }
}

interface Marry {
    void HappyMarry();
}

//真实角色，你去结婚
class You implements Marry {

    @Override
    public void HappyMarry() {

        System.out.println("xx要结婚了");
    }
}

//代理角色，帮助你结婚
class WeddingCompany implements Marry {
    //代理谁--> 真实目标角色
    private Marry target;

    public WeddingCompany(Marry target) {
        this.target = target;
    }

    @Override
    public void HappyMarry() {
        before();
        //这就是真实对象
        this.target.HappyMarry();
        after();
    }

    private void after() {
        System.out.println("结婚之后，收尾款");
    }

    private void before() {
        System.out.println("结婚之前，布置现场");
    }

}
```

### 5.Lambda表达式

`入`希腊字母表中排序第十一位的字母，英语名称为Lambda

避免内部类定义过多，其实质属于函数式编程概念

```java
（params） -> expression  [表达式]
（params） -> statement [语句]
（params） -> {statement }
```

**为什么要使用lambda 表达式**

  1.避免匿名内部类定义过多

  2.可以让你的代码看起来很简洁

  3.去掉了一堆没有意义的代码，只留下核心的逻辑

**函数式接口的定义**

  1.任何接口，如果只包含**唯一一个抽象方法**，那么它就是一个`函数式接口`。

  2.对于函数式接口，我们可以通过lambda 表达式来创建该接口的对象。

```java
public interface Runnable{
    public abstract void run();
}
```

**案例1：**

```java
/**
 * @Description Testlambda
 * @Author vchicken
 * @Date 2022/8/30 19:31
 */
public class TestLambda {

    //3.静态内部类
    static class Like2 implements ILike {
        @Override
        public void lambda() {
            System.out.println(" I like lambda2");
        }
    }

    public static void main(String[] args) {
        ILike like = new Like();
        like.lambda();

        like = new Like2();
        like.lambda();

        //4.局部内部类
        class Like3 implements ILike {
            @Override
            public void lambda() {
                System.out.println(" I like lambda3");
            }
        }

        like = new Like3();
        like.lambda();

        //5.匿名内部类,没有类的名称，必须借助接口或者父类
        like = new ILike() {
            @Override
            public void lambda() {
                System.out.println(" I like lambda4");
            }
        };

        like.lambda();

        //6.用lambda表达式
        like = ()->{
            System.out.println(" i like lambda5");
        };
        like.lambda();
    }
}

//1.定义一个函数式接口
interface ILike {
    void lambda();
}

//2.实现类
class Like implements ILike {

    @Override
    public void lambda() {
        System.out.println(" I like lambda");
    }
}
```

**案例2：**

```java
/**
 * @Description TestLambda2
 * @Author vchicken
 * @Date 2022/8/30 19:42
 */
public class TestLambda2 {

    public static void main(String[] args) {
        class Love implements ILove {

            @Override
            public void love(int a) {
                System.out.println("I love a" + a);
            }
        }

        ILove love = new Love();
        love.love(1);

        love = new ILove() {

            @Override
            public void love(int a) {
                System.out.println("I love b" + a);
            }
        };

        love.love(2);

        love = (a) -> {
            System.out.println("I love c" + a);
        };

        love.love(3);

        love = a -> {
            System.out.println("I love d" + a);
        };

        love.love(4);

        love = a -> System.out.println("I love e" + a);
        
        love.love(5);
    }
}

interface ILove {
    void love(int a);
}
```

### 6.线程状态



#### 线程的状态

![线程状态](https://img-blog.csdnimg.cn/1984a898e6924e4ba44b6a3a492a893c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)
![线程状态描述](https://img-blog.csdnimg.cn/a8e1138a4078491db6f26235ca51bcbf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)



#### 线程方法

![线程方法](https://img-blog.csdnimg.cn/0b8070d3b2164eb6ae51c64de742dadb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)



**线程停止**

  1. 不用使用stop或destory 等过时或者JDK 不建议使用的方法

     

  2. 推荐线程自己停止下来

     

  3. 建议使用标志位进行终止变量，当flag=false，则终止线程运行。

**线程休眠（sleep）**

  1. sleep（时间）指定当前线程阻塞的**毫秒数**；

     

  2. sleep 存在异常InterruptedException；

     

  3. sleep 时间达到后线程进入就绪状态

     

  4. sleep 可以模拟网络延时，倒计时等。

     

  5. 每一个对象都有一个锁，sleep不会释放锁；

**案例1：模拟网络延时**

```java
/**
 * @Description TestSleep
 * @Author vchicken
 * @Date 2022/8/30 20:26
 */
public class TestSleep implements Runnable {

    //票数
    private int ticketNums = 10;

    @Override
    public void run() {
        while (true) {
            if (ticketNums <= 0) {
                break;
            }
            //模拟延时
            try {
                Thread.sleep(100);
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "--->拿到了第" + ticketNums-- + "票");
        }

    }

    public static void main(String[] args) {
        TestSleep testSleep = new TestSleep();

        new Thread(testSleep, "小明").start();
        new Thread(testSleep, "小红").start();
        new Thread(testSleep, "黄牛党").start();

    }
}
```

**案例2：模拟倒计时 、打印当前系统时间**

```java
/**
 * @Description TestSleep2
 * @Author vchicken
 * @Date 2022/8/30 20:28
 */
public class TestSleep2 {

    /**
     * 模拟倒计时
     *
     * @throws InterruptedException
     */
    public static void testDown() throws InterruptedException {
        int num = 10;
        while (true) {
            Thread.sleep(1000);
            System.out.println(num--);
            if (num == 0) {
                break;
            }
        }
    }

    /**
     * 打印当前时间
     */
    public static void printNowDate() {
        //打印当前系统时间
        Date stattTime = new Date(System.currentTimeMillis());
        while (true) {
            try {
                //休眠1秒
                Thread.sleep(1000);
                //格式化时间,并输出时间
                System.out.println(new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss").format(stattTime));
                //更新获取时间
                stattTime = new Date(System.currentTimeMillis());
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }

    public static void main(String[] args) {
        printNowDate();
    }
}
```

**线程礼让（yield）**

  1. 礼让线程，让当前**正在执行的线程暂停**，**但不阻塞**

     

  2. 将线程从**运行状态**转为**就绪状态**

     

  3. 让cpu 重新调度，**礼让不一定成功**！看cpu心情

     

  4. 该方法只是对线程调度器的一个建议，而且也只是建议**具有相同优先级**的其它线程可以运行。

```java
/**
 * @Description TestYield
 * @Author vchicken
 * @Date 2022/8/30 20:31
 */
public class TestYield {

    public static void main(String[] args) {
        MyYield myYield = new MyYield();

        new Thread(myYield, "A").start();
        new Thread(myYield, "B").start();

    }
}


class MyYield implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "线程开始执行");
        //礼让
        Thread.yield();
        System.out.println(Thread.currentThread().getName() + "线程停止执行");
    }

}
```

**线程强制执行：（join）**
**Join 合并线程**，待此线程执行完成后，再执行其他线程，**其他线程阻塞**，可以想象成插队。

![插队](https://img-blog.csdnimg.cn/d128e06c246f4533aeb19c3c91cf05ec.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

```java
/**
 * @Description TestJoin
 * @Author vchicken
 * @Date 2022/8/30 20:37
 */
public class TestJoin implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("线程VIP 来了" + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        //启动线程
        thread.start();

        //主线程
        for (int i = 0; i < 200; i++) {
            if (i == 100) {
                thread.join();//插队
            }
            System.out.println("main" + i);
        }

    }
}
```

**线程优先级**

- Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器安装优先级决定应该调度哪个线程来执行。

- 线程的优先级用数字表示，范围从1——10

  

  - Thread.MIN_PRIORITY = 1;

    

  - Thread.MAX_PRIORITY = 10;

    

  - Thread.NOPM_PRIORITY = 5;

    

- 使用以下方式改变或获取优先级

  - getPriority()
  - setPriority(int xx)

```java
/**
 * @Description TestPriority
 * @Author vchicken
 * @Date 2022/8/30 21:05
 */
public class TestPriority {

    public static void main(String[] args) {
        //主线程默认优先级
        System.out.println(Thread.currentThread().getName() + "==" + Thread.currentThread().getPriority());

        MyPriority myPriority = new MyPriority();
        Thread t1 = new Thread(myPriority);
        Thread t2 = new Thread(myPriority);
        Thread t3 = new Thread(myPriority);
        Thread t4 = new Thread(myPriority);
        Thread t5 = new Thread(myPriority);
        Thread t6 = new Thread(myPriority);
        //先设置优先级，再启动
        t1.start();
        t2.setPriority(1);
        t2.start();

        t3.setPriority(4);
        t3.start();

        //MAX_PRIORITY=10
        t4.setPriority(Thread.MAX_PRIORITY);
        t4.start();

        //   t5.setPriority(-1);//通过查看源码发现，设置优先级为-1会报错（小于1）
        //  t5.start();

        // t6.setPriority(11);//通过查看源码发现，设置优先级为11会报错（大于10）
        //t6.start();

        t5.setPriority(8);
        t5.start();

        t6.setPriority(7);
        t6.start();
    }
}

class MyPriority implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "==" + Thread.currentThread().getPriority());
    }
}
```

优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用，这都是看CPU的调度。

**守护(daemon)线程**

`守护线程`是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。

1. 线程分为**用户线程**和**守护线程**
2. 虚拟机必须确保**用户线程**执行完毕，虚拟机不用等待**守护线程**执行完毕
3. 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。
4. main() 属于非守护线程，即用户线程。
5. 使用 setDaemon() 方法将一个线程设置为守护线程。

如：后台记录操作日志、监控内存、垃圾回收等等…

```java
/**
 * @Description TestDaemon
 * @Author vchicken
 * @Date 2022/8/30 21:14
 */
public class TestDaemon {

    public static void main(String[] args) {
        God god = new God();
        Your you = new Your();

        Thread thread = new Thread(god);
        //默认是false表示是用户线程，正常的线程都是用户线程
        thread.setDaemon(true);

        //上帝守护线程启动
        thread.start();

        //你 用户线程启动
        new Thread(you).start();

    }
}

/**
 * 你
 */
class Your implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 36500; i++) {
            System.out.println("你一生都开心活着");
        }
        System.out.println("=========goodbye! world=======");
    }
}

/**
 * 上帝
 */
class God implements Runnable {
    @Override
    public void run() {
        while (true) {
            System.out.println("上帝保护着你");
        }
    }
}
```

**Executor **

`Executor` 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。 
主要有三种 Executor: 

- **CachedThreadPool**: 一个任务创建一个线程； 
- **FixedThreadPool**: 所有任务只能使用固定大小的线程；
- **SingleThreadExecutor**: 相当于大小为 1 的 FixedThreadPool。

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}

```


### 7.线程状态观测

**1.新建(New)**

**尚未启动的线程处于此状态**。

**2.可运行(Runnable)** 

**在Java虚拟机中执行的线程处于此状态**。可能正在运行，也可能正在等待 CPU 时间片。包含了操作系统线程状态中的 **Running**和 **Ready**。 

**3.阻塞(Blocked)** 

**被阻塞等待监视器锁定的线程处于此状态**。等待获取一个排它锁，如果其线程释放了锁就会结束此状态。 

**4.无限期等待(Waiting)** 

**正在等待另一个线程执行特定动作的线程处于此状态**。等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。 

| 进入方法                                   | 退出方法                             |
| ------------------------------------------ | ------------------------------------ |
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                 |
| LockSupport.park() 方法                    | -                                    |

**5.限期等待(Timed Waiting)** 

**正在等待另一个线程执行动作达到指定等待时间的线程处于此状态**。无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 
调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。 
调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。 
睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 
阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。 
![限期等待](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-30/72f90c92-167c-4a78-b4ae-decc8d9efb54.png)

**6.死亡(Terminated)** 

**已退出的线程处于此状态**。可以是线程结束任务之后自己结束，或者产生了异常而结束。

**线程状态转换**

![线程状态转换](https://www.pdai.tech/_images/pics/ace830df-9919-48ca-91b5-60b193f593d2.png)

```java
/**
 * @Description TeetState
 * @Author vchicken
 * @Date 2022/8/30 20:56
 */
public class TestState {

    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.out.println("/");
            }
        });

        //观察状态
        Thread.State state = thread.getState();
        System.out.println(state);

        //观察启动后
        thread.start();
        state = thread.getState();
        System.out.println(state);
        //只要线程不终止，就一直输出状态
        while (state != Thread.State.TERMINATED) {
            Thread.sleep(100);
            state = thread.getState();//更新线程状态
            System.out.println(state);//输出线程状态
        }

    }
}
```

注意：**线程中断或结束，一旦进入死亡状态，就不能再次启动**。


### 8.线程同步

多个线程操作同一个资源

**并发：**同一个对象被多个线程同时操作。

- 现实生活中，我们会遇到“同一资源，多个人都想使用”的问题，比如：食堂排队打饭，每个人都想吃饭，最天然的解决办法就是，排队，一个个来。
  ![排队](https://img-blog.csdnimg.cn/f12bacb3f04c4bcebb60716949925be2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

- 处理多线程问题时，多个线程访问同一个对象（并发），并且某些线程还想修改这个对象，这个时候我们就需要**线程同步**，线程同步就是一种机制，**多个需要同时访问此对象的线程进入这个对象的等待池形成队列**，等待前面线程使用完毕，下一个线程再使用。

**队列和锁**

​	由于同一个进程的**多个线程共享同一块存储空间**，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入 `锁机制 synchronized` ，当一个线程获得对象的**排它锁**，独占资源，其他线程必须等待，使用后释放锁即可。
**存在以下问题：**

  1.一个线程有锁会导致**其他需要此锁的线程挂起**；

  2.在多线程竞争下，加锁，释放锁会导致比较多的`上下文切换`和`调度延时`，引起性能问题；

  3.如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致**优先级倒置**，引起性能问题。

**线程不安全案例1：不安全的买票**

```java
/**
 * @Description UnsafeBuyTicket
 * @Author vchicken
 * @Date 2022/8/30 21:32
 */
public class UnsafeBuyTicket {
    public static void main(String[] args) {

        BuyTicket station = new BuyTicket();

        new Thread(station, "小明").start();
        new Thread(station, "小蓝").start();
        new Thread(station, "黄牛").start();

    }

}

class BuyTicket implements Runnable {

    /**
     * 票
     */
    private int ticketNums = 10;


    /**
     * 外部停止方式
     */
    private boolean flag = true;

    @Override
    public void run() {
        //买票
        while (flag) {
            buy();
        }
    }

    private void buy() {
        //判断是否有票
        if (ticketNums <= 0) {
            flag = false;
            return;
        }
        //模拟延时
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        //买票
        System.out.println(Thread.currentThread().getName() + "拿到" + ticketNums-- + "张票");
    }
}
```

**线程不安全案例2：不安全的取钱**

```java
/**
 * @Description UnsafeBank
 * @Author vchicken
 * @Date 2022/8/30 21:35
 */
public class UnsafeBank {
    public static void main(String[] args) {
        //账户
        Account account = new Account(100, "结婚基金");
        Drawing you = new Drawing(account, 50, "你");
        Drawing girlFriend = new Drawing(account, 100, "girlFriend");

        you.start();
        girlFriend.start();

    }

}

/**
 * 账户
 */
class Account {
    /**
     * 余额
     */
    int money;

    /**
     * 卡名
     */
    String name;

    public Account(int money, String name) {
        this.money = money;
        this.name = name;
    }
}

/**
 * 银行：模拟取款
 */
class Drawing extends Thread {

    /**
     * 账户
     */
    Account account;
    
    /**
     * 取了多少钱
     */
    int drawingMoney;
    
    /**
     * 现在手里有多少钱
     */
    int nowMoney;

    public Drawing(Account account, int drawingMoney, String name) {
        super(name);
        this.account = account;
        this.drawingMoney = drawingMoney;
    }

    @Override
    public void run() {
        //判断有没有钱
        if (account.money - drawingMoney < 0) {
            System.out.println(Thread.currentThread().getName() + "钱不够，取不了");
            return;
        }

        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


        //卡内余额 = 余额 减去 你取的前
        account.money = account.money - drawingMoney;
        //你手里的钱
        nowMoney = nowMoney + drawingMoney;

        System.out.println(account.name + "余额为：" + account.money);
        //Thread.currentThread().getName() = this.getName();
        System.out.println(this.getName() + "手里的钱" + nowMoney);

    }
}
```

**线程不安全案例3：不安全的集合**

```java
/**
 * @Description UnsafeList
 * @Author vchicken
 * @Date 2022/8/30 21:49
 */
public class UnsafeList {

    public static void main(String[] args) throws InterruptedException {

        List<String> list = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            new Thread(()->{
                list.add(Thread.currentThread().getName());
            }).start();
        }
        Thread.sleep(3000);
        System.out.println(list.size());

 
   }
}

//运行结果
9998
```

#### 同步方法

  由于我们可以通过private 关键字来保证数据对象只能被方法访问，所以我们只需要对方法提出一套机制，这套机制就是`synchronized关键字`，它包括两种用法：**synchronized方法**和**synchronized块**；

```java
同步方法：public synchronized void method(int args){}
```

`synchronized方法` 控制对 “**对象**”的访问，每个对象对应一把锁，每个synchronized 方法都必须**获得调用该方法的对象的锁才能执行**，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。

- 缺陷：若将一个大的方法声明为synchronized 将会影响效率。方法里面需要修改的内容才需要锁，锁的太多，浪费资源。

![](https://img-blog.csdnimg.cn/3fdf221e9f6a4fe0a86933ac8a521157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

#### 同步块

**同步块**：synchronized (obj){ }

- obj 称之为`同步监视器`
- obj 可以是**任何对象**，但是推荐使用**共享资源**作为同步监视器

同步方法中无需指定同步监视器，因为同步方法的同步监视器就是**this**，就是和这个**对象本身**，或者是**class**

**同步监视器的执行过程**

1. 第一个线程访问，锁定同步监视器，执行其中代码
2. 第二个线程访问，发现同步监视器，无法访问
3. 第一个线程访问完毕，解锁同步监视器
4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问

锁的对象就是**变化的量**，需要增删改的数据

### 9.死锁

**概念：**
  多个线程各自占有一些资源，并且**互相等待其他线程占有的资源才能运行**，而导致这**两个或者多个线程**都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“**两个以上对象的锁时**”，就可能发生“死锁”的问题。

**死锁案例：**

```java
/**
 * @Description TestLock
 * @Author vchicken
 * @Date 2022/8/31 20:28
 */
public class TestLock {
    public static void main(String[] args) {
        Makeup g1 = new Makeup(0, "灰姑凉");
        Makeup g2 = new Makeup(1, "白雪公主");

        g1.start();
        g2.start();


    }
}


class Lipstick {

}

/**
 * 镜子
 */
class Mirror {

}

class Makeup extends Thread {

    //需要的资源只有一份，用static 来保证只有一份
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();

    /**
     * 选择
     */
    int choice;

    /**
     * 使用化妆品的人
     */
    String girlName;

    public Makeup(int choice, String girlName) {
        this.choice = choice;
        this.girlName = girlName;
    }

    @Override
    public void run() {

        try {
            makeup();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

    //化妆，互相持有对方的锁，就是需要拿到对方的资源
    private void makeup() throws InterruptedException {
        if (choice == 0) {
            //获得口红的锁
            synchronized (lipstick) {
                System.out.println(this.girlName + "获得口红的锁");
                Thread.sleep(100);

                synchronized (mirror) {//一秒钟后想获得镜子
                    System.out.println(this.girlName + "获得镜子的锁");
                }

            }
        } else {
            //想获得镜子的锁
            synchronized (mirror) {
                System.out.println(this.girlName + "获得镜子的锁");
                Thread.sleep(100);
                //一秒钟后想获得口红
                synchronized (lipstick) {
                    System.out.println(this.girlName + "获得口红的锁");

                }
            }
        }
    }
}
```

**产生死锁的四个必要条件：**

1. **互斥条件**：一个资源每次只能被一个进程使用。
2. **请求与保持条件**：一个进程因请求资源而阻塞，对已获得的资源保持不放。
3. **不剥夺条件**：进程已获得的资源，在未使用完之前，不能强行剥夺。
4. **循环等待条件**：若干个进程之间形成一种头尾相接的循环等待资源关系。

> 我们只需要想办法破坏其中的任意一个条件或者多个条件，就可以避免发生死锁。

### 10.Lock(锁)

**ReentrantLock 可重入锁**

1. 从JDK 5.0开始，Java提供了更强大的线程同步机制——通过**显式定义同步锁对象**来实现同步。**同步锁使用Lock对象充当**
2. java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，**每次只能有一个线程对Lock对象加锁**，**线程开始访问共享资源之前应先获得Lock对象**。
3. `ReentrantLock类`实现了Lock，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以**显式加锁、释放锁**。

**lock锁案例:**

```java
/**
 * @Description TestLock
 * @Author vchicken
 * @Date 2022/8/31 20:53
 */
public class TestLock {
    public static void main(String[] args) {

        TestLock2 lock2 = new TestLock2();
        new Thread(lock2, "闲言").start();
        new Thread(lock2, "鸡哥").start();
        new Thread(lock2, "黄牛").start();

    }
}

class TestLock2 implements Runnable {

    int ticketNums = 10;

    //定义lock锁
    private final ReentrantLock lock = new ReentrantLock();


    @Override
    public void run() {
        while (true) {
            try {
                lock.lock();//加锁
                if (ticketNums > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + " " + ticketNums--);

                } else {
                    break;
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();//解锁
            }
        }
    }
}
```

**Synchronized 与 Lock 的对比**

1. Lock是显式锁（手动开启和关闭锁，别忘记关闭锁) synchronized是**隐式锁**，**出了作用域自动释放**
2. Lock只有**代码块锁**,synchronized有**代码块锁**和**方法锁**
3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)
4. 优先使用顺序:

Lock > 同步代码块 （已经进入了方法体，分配相应资源） > 同步方法（在方法体之外）

### 11.线程协作

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。

#### join()

在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。

对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。

```java
public class JoinExample {

    private class A extends Thread {
        @Override
        public void run() {
            System.out.println("A");
        }
    }

    private class B extends Thread {

        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("B");
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}
```

```java
public static void main(String[] args) {
    JoinExample example = new JoinExample();
    example.test();
}

//运行结果
A
B
```



#### wait() notify() notifyAll()

调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。

它们都属于 Object 的一部分，而不属于 Thread。

只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。

**使用 wait() 挂起期间，线程会释放锁**。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。

```java
public class WaitNotifyExample {
    public synchronized void before() {
        System.out.println("before");
        notifyAll();
    }

    public synchronized void after() {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("after");
    }
}
```

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    WaitNotifyExample example = new WaitNotifyExample();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}
//执行结果
before
after
```

**wait() 和 sleep() 的区别**

- wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
- wait() 会释放锁，sleep() 不会。

#### await() signal() signalAll()

java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。

使用 Lock 来获取一个 Condition 对象。

```java
public class AwaitSignalExample {
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void before() {
        lock.lock();
        try {
            System.out.println("before");
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println("after");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}
//执行结果
before
after
```



#### 应用场景：生产者和消费者问题

1. 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库﹐消费者将仓库中产品取走消费。
2. 如果仓库中没有产品﹐则生产者将产品放入仓库﹐否则停止生产并等待，直到仓库中的产品被消费者取走为止。
3. 如果仓库中放有产品,则消费者可以将产品取走消费﹐否则停止消费并等待，直到仓库再次放入产品为止。
   ![](https://img-blog.csdnimg.cn/b7cda02290d34aa8896c8c9db90d5891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)

 这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。

1. 对于生产者﹐没有生产产品之前，要通知消费者等待﹒而生产了产品之后﹐又需要马上通知消费者消费
2. 对于消费者﹐在消费之后﹐要通知生产者已经结束消费﹐需要生产新的产品以供消费.
3. 在生产者消费者问题中,仅有synchronized是不够的

- synchronized可阻止并发更新同一个共享资源，实现了同步
- synchronized不能用来实现不同线程之间的消息传递(通信)

Java提供了几个方法解决线程之间的通信问题
![](https://img-blog.csdnimg.cn/3c55464a5df84effb96a425524fd9e7f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDI1Nzk4,size_16,color_FFFFFF,t_70#pic_center)
**注意**：上图中均是**Object类**提供的方法，都只能在**同步方法**或者**同步代码块**中使用，否则会抛出lllegalMonitorStateException。

**解决方式1：**
并发协作模型“生产者/消费者模式”——>**管程法**

1. **生产者**:负责生产数据的模块(可能是方法,对象,线程,进程);
2. **消费者**∶负责处理数据的模块(可能是方法,对象,线程,进程);
3. **缓冲区**:消费者不能直接使用生产者的数据,他们之间有个“缓冲区”

**生产者将生产好的数据放入缓冲区,消费者从缓冲区拿出数据**

**解决方式2：**
并发协作模型“生产者/消费者模式”——>**信号灯法**

**案例1：管程法**

```java
/**
 * @Description TestPC 管程法
 * @Author vchicken
 * @Date 2022/8/31 21:16
 */
public class TestPC {
    public static void main(String[] args) {

        SynContainer container = new SynContainer();

        new Productor(container).start();
        new Consumer(container).start();

    }
}

//生产者
class Productor extends Thread {
    SynContainer container;

    public Productor(SynContainer container) {
        this.container = container;
    }

    //生产
    @Override
    public void run() {
        for (int i = 1; i <= 20; i++) {
            container.push(new Chiken(i));
            System.out.println("生产了" + i + "只鸡");
        }
    }
}

//消费者
class Consumer extends Thread {
    SynContainer container;

    public Consumer(SynContainer container) {
        this.container = container;
    }

    //生产
    @Override
    public void run() {
        for (int i = 1; i <= 20; i++) {
            Chiken pop = container.pop();
            System.out.println("消费了第" + pop.id + "只鸡");
        }
    }
}

//产品
class Chiken {
    int id;//编号

    public Chiken(int id) {
        this.id = id;
    }
}

//缓冲区
class SynContainer {

    //需要一个容器大小
    Chiken[] chikens = new Chiken[10];
    //容器计数器
    int count = 0;

    //生产者放入产品
    public synchronized void push(Chiken chiken) {
        //如果容器满了，就需要等待消费者消费
        if (count == chikens.length) {
            //通知消费者消费，生产者等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //如果容器没有满，我们就需要丢入产品
        chikens[count] = chiken;
        count++;
        //通知消费者消费
        this.notifyAll();
    }

    //通知消费者消费
    public synchronized Chiken pop() {
        //判断能否消费
        if (count == 0) {
            //等待生产者生产，消费者等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //如果可以消费
        count--;
        Chiken chiken = chikens[count];
        //吃完了，通知生产者生产
        this.notifyAll();
        return chiken;
    }
}
```

**案例2：信号灯法**

```java
/**
 * @Description TestPC2 信号灯法
 * @Author vchicken
 * @Date 2022/8/31 21:25
 */
public class TestPC2 {

    public static void main(String[] args) {
        TV tv = new TV();
        new Player(tv).start();
        new Watcher(tv).start();
    }
}

/**
 * 生产者：演员
 */
class Player extends Thread {
    TV tv;

    public Player(TV tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if (i % 2 == 0) {
                this.tv.play("快乐大本营播放中");
            } else {
                this.tv.play("抖音记录美好生活");
            }
        }
    }
}

/**
 * 消费者：观众
 */
class Watcher extends Thread {
    TV tv;

    public Watcher(TV tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {

            tv.watch();
        }
    }
}

/**
 * 产品：节目
 */
class TV {

    /**
     * 表演的节目
     */
    String voice;

    boolean flag = true;

    public synchronized void play(String voice) {
        if (!flag) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("演员表演了:" + voice);
        //通知观众观看
        this.notifyAll();
        this.voice = voice;
        this.flag = !this.flag;
    }

    public synchronized void watch() {
        if (flag) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("观看了：" + voice);
        //通知演员表演
        this.notifyAll();
        this.flag = !this.flag;
    }

}
```



### 12.线程池

**背景**:经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。

**思路**︰提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。

**好处:**

1. 提高响应速度（减少了创建新线程的时间)
2. 降低资源消耗（重复利用线程池中线程，不需要每次都创建)
3. 便于线程管理(…)

   - corePoolSize:核心池的大小
   - maximumPoolSize:最大线程数
   - keepAliveTime:线程没有任务时最多保持多长时间后会终止

**JDK 5.0起提供了线程池相关API:**

  `ExecutorService`和`Executors`

- ExecutorService:真正的线程池接口。
  - 常见子类ThreadPoolExecutor
  - void execute(Runnable cgmmand):执行任务/命令，没有返回值，一般用来执行Runnable
  - Future submit(Callable task):执行任务，有返回值，一般又来执行Callable
  - void shutdown():关闭连接池

- Executors:
  工具类、线程池的工厂类，用于创建并返回不同类型的线程池`

```java
/**
 * @Description TestPool
 * @Author vchicken
 * @Date 2022/8/31 21:51
 */
public class TestPool {
    public static void main(String[] args) {

        //1.创建服务，创建线程池
        ExecutorService service = Executors.newFixedThreadPool(10);

        //执行
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());

        //2.关闭连接
        service.shutdown();

    }
}

class MyThread implements Runnable {


    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```

## **Java并发—Java锁的种类**

### 前言

Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。

Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：

![Java主流锁的分类](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/9cc6742f-9c37-45a3-8f12-c6ddd832544e.png)

### 1. 乐观锁 VS 悲观锁

> 乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。

先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，**synchronized关键字和Lock的实现类都是悲观锁**。

而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。

乐观锁在Java中是通过使用**无锁编程**来实现，最常采用的是**CAS算法**，Java原子类中的递增操作就通过CAS自旋实现的。

![乐观锁 VS 悲观锁](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/fa662117-37d7-4620-aa0b-1eb9a8dcd2db.png)

根据从上面的概念描述我们可以发现：

- **悲观锁适合写操作多的场景**，先加锁可以保证写操作时数据正确。
- **乐观锁适合读操作多的场景**，不加锁的特点能够使其读操作的性能大幅提升。

光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：


```java
// ------------------------- 悲观锁的调用方式 -------------------------
// synchronized
public synchronized void testMethod() {
	// 操作同步资源
}
// ReentrantLock
private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁
public void modifyPublicResources() {
	lock.lock();
	// 操作同步资源
	lock.unlock();
}

// ------------------------- 乐观锁的调用方式 -------------------------
private AtomicInteger atomicInteger = new AtomicInteger();  // 需要保证多个线程使用的是同一个AtomicInteger
atomicInteger.incrementAndGet(); //执行自增1
```

通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？具体可以参看[JUC原子类: CAS, Unsafe和原子类详解]()。

### 2.自旋锁 VS 适应性自旋锁

> 在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。

在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

![自旋锁 VS 适应性自旋锁](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/db33e4ae-12e0-4696-8d87-986ffad08858.png)


自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。

自旋锁相关可以看[关键字 - synchronized详解 - 自旋锁与自适应自旋锁  (opens new window)](https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html#自旋锁与自适应自旋锁)

### 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁

> 这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。

总结而言： 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

![无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/0fbd39a5-882e-40d0-9b7a-a66bcc1989d1.png)

相关可以看[关键字 - synchronized详解 - 锁的类型  (opens new window)](https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html#锁的类型)

### 4. 公平锁 VS 非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。

![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/cfac696f-71bc-4d6b-9b12-1586d31f4b50.png)

如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。

但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：

![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/3aa09344-de8b-48a0-8479-dfef3f73407a.png)


更多请参看[JUC - ReentrantLock详解  (opens new window)](https://pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html)。

### 5. 可重入锁 VS 非可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是**可一定程度避免死锁**。下面用示例代码来进行分析：

```java
public class Widget {
    public synchronized void doSomething() {
        System.out.println("方法1执行...");
        doOthers();
    }

    public synchronized void doOthers() {
        System.out.println("方法2执行...");
    }
}
```

在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。

如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。

而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。

还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。

![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/d055d667-ce2a-4b81-8389-68d338f026b5.png)


但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。

![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/1cd83d55-0c64-4940-81a7-79dd3a9402b8.png)


之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。

首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。

当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。

释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。

![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/451a8647-554c-4142-8385-1d8268ba471a.png)


更多请参看：

- [JUC锁: LockSupport详解]()
- [JUC锁: AbstractQueuedSynchonizer详解]()
- [JUC锁 - ReentrantLock详解  (opens new window)](https://pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html)。
- [关键字 - synchronized详解  (opens new window)](https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html)

### 6. 独享锁(排他锁) VS 共享锁

> 独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。

**独享锁也叫排他锁**，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。

**共享锁**是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。

独享锁与共享锁也是通过AQS(全称是 AbstractQueuedSynchronizer，中文译为抽象队列式同步器)来实现的，通过实现不同的方法，来实现独享或者共享。

下图为ReentrantReadWriteLock的部分源码：

![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-02/12e75062-f806-4f20-8dbb-c4e6e6ad98f8.png)


我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。

在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。

更多请参看

- [JUC锁: ReentrantReadWriteLock详解  (opens new window)](https://pdai.tech/md/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html)

### 结语

本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。

其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。



## **Java并发—ThreadLocal详解**

### ThreadLocal简介

我们在[Java 并发—理论基础](#Java并发—理论基础)总结过线程安全(是指广义上的共享资源访问安全性，因为线程隔离是通过副本保证本线程访问资源安全性，它不保证线程之间还存在共享关系的狭义上的安全性)的解决思路：

- **互斥同步**: synchronized 和 ReentrantLock
- **非阻塞同步**: CAS, AtomicXXXX
- **无同步方案**: 栈封闭，本地存储(Thread Local)，可重入代码

这个章节将详细的讲讲 本地存储(Thread Local)。官网的解释是这样的：

> This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID) 
>
> 该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量(通过其 get 或 set 方法)的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 ID 或事务 ID)相关联。

**总结而言**：ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。

### ThreadLocal理解

> 提到ThreadLocal被提到应用最多的是**session**管理和**数据库链接**管理，这里以数据访问为例帮助你理解ThreadLocal：

- 如下数据库管理类在单线程使用是没有任何问题的

```java
class ConnectionManager {
    private static Connection connect = null;

    public static Connection openConnection() {
        if (connect == null) {
            connect = DriverManager.getConnection();
        }
        return connect;
    }

    public static void closeConnection() {
        if (connect != null)
            connect.close();
    }
}
```

很显然，在多线程中使用会存在线程安全问题：

​	第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；

​	第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。

- 为了解决上述线程安全的问题，第一考虑：**互斥同步**

你可能会说，将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理，比如用Synchronized或者ReentrantLock互斥锁。

- 这里再抛出一个问题：这地方到底需不需要将connect变量进行共享?

事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。即改后的代码可以这样：

```java
class ConnectionManager {
    private Connection connect = null;

    public Connection openConnection() {
        if (connect == null) {
            connect = DriverManager.getConnection();
        }
        return connect;
    }

    public void closeConnection() {
        if (connect != null)
            connect.close();
    }
}

class Dao {
    public void insert() {
        ConnectionManager connectionManager = new ConnectionManager();
        Connection connection = connectionManager.openConnection();
        // 使用connection进行操作
        connectionManager.closeConnection();
    }
}
```

这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不仅严重影响程序执行效率，还可能导致服务器压力巨大。

- 这时候ThreadLocal登场了

那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。下面就是网上出现最多的例子：

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ConnectionManager {

    private static final ThreadLocal<Connection> dbConnectionLocal = new ThreadLocal<Connection>() {
        @Override
        protected Connection initialValue() {
            try {
                return DriverManager.getConnection("", "", "");
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return null;
        }
    };

    public Connection getConnection() {
        return dbConnectionLocal.get();
    }
}
```

- 再注意下ThreadLocal的修饰符

ThreaLocal的JDK文档中说明：ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread。如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。

> 但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。



### ThreadLocal原理

#### 如何实现线程隔离

主要是用到了Thread对象中的一个ThreadLocalMap类型的变量threadLocals, 负责存储当前线程的关于Connection的对象, dbConnectionLocal(以上述例子中为例) 这个变量为Key, 以新建的Connection对象为Value; 这样的话, 线程第一次读取的时候如果不存在就会调用ThreadLocal的initialValue方法创建一个Connection对象并且返回;

具体关于为线程分配变量副本的代码如下:

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap threadLocals = getMap(t);
    if (threadLocals != null) {
        ThreadLocalMap.Entry e = threadLocals.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

- 首先获取当前线程对象t, 然后从线程t中获取到ThreadLocalMap的成员属性threadLocals
- 如果当前线程的threadLocals已经初始化(即不为null) 并且存在以当前ThreadLocal对象为Key的值, 则直接返回当前线程要获取的对象(本例中为Connection);
- 如果当前线程的threadLocals已经初始化(即不为null)但是不存在以当前ThreadLocal对象为Key的的对象, 那么重新创建一个Connection对象, 并且添加到当前线程的threadLocals Map中,并返回
- 如果当前线程的threadLocals属性还没有被初始化, 则重新创建一个ThreadLocalMap对象, 并且创建一个Connection对象并添加到ThreadLocalMap对象中并返回。

如果存在则直接返回很好理解, 那么对于如何初始化的代码又是怎样的呢?

```java
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}
```

- 首先调用我们上面写的重写过后的initialValue方法, 产生一个Connection对象
- 继续查看当前线程的threadLocals是不是空的, 如果ThreadLocalMap已被初始化, 那么直接将产生的对象添加到ThreadLocalMap中, 如果没有初始化, 则创建并添加对象到其中;

同时, ThreadLocal还提供了直接操作Thread对象中的threadLocals的方法

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

这样我们也可以不实现initialValue, 将初始化工作放到DBConnectionFactory的getConnection方法中:

```java
public Connection getConnection() {
    Connection connection = dbConnectionLocal.get();
    if (connection == null) {
        try {
            connection = DriverManager.getConnection("", "", "");
            dbConnectionLocal.set(connection);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    return connection;
}
```

那么我们看过代码之后就很清晰的知道了为什么ThreadLocal能够实现变量的多线程隔离了; 其实就是用了Map的数据结构给当前线程缓存了, 要使用的时候就从本线程的threadLocals对象中获取就可以了, key就是当前线程;

当然了在当前线程下获取当前线程里面的Map里面的对象并操作肯定没有线程并发问题了, 当然能做到变量的线程间隔离了;

现在我们知道了ThreadLocal到底是什么了, 又知道了如何使用ThreadLocal以及其基本实现原理了是不是就可以结束了呢? 其实还有一个问题就是ThreadLocalMap是个什么对象, 为什么要用这个对象呢?

#### ThreadLocalMap对象是什么

本质上来讲, 它就是一个Map, 但是这个ThreadLocalMap与我们平时见到的Map有点不一样

- 它没有实现Map接口;
- 它没有public的方法, 最多有一个default的构造方法, 因为这个ThreadLocalMap的方法仅仅在ThreadLocal类中调用, 属于静态内部类
- ThreadLocalMap的Entry实现继承了WeakReference<ThreadLocal<?>>
- 该方法仅仅用了一个Entry数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;

要了解ThreadLocalMap的实现, 我们先从入口开始, 就是往该Map中添加一个值:

```java
private void set(ThreadLocal<?> key, Object value) {

    // We don't use a fast path as with get() because it is at
    // least as common to use set() to create new entries as
    // it is to replace existing ones, in which case, a fast
    // path would fail more often than not.

    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);

    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
```

先进行简单的分析, 对该代码表层意思进行解读:

- 看下当前threadLocal的在数组中的索引位置 比如: `i = 2`, 看 `i = 2` 位置上面的元素(Entry)的`Key`是否等于threadLocal 这个 Key, 如果等于就很好说了, 直接将该位置上面的Entry的Value替换成最新的就可以了;
- 如果当前位置上面的 Entry 的 Key为空, 说明ThreadLocal对象已经被回收了, 那么就调用replaceStaleEntry
- 如果清理完无用条目(ThreadLocal被回收的条目)、并且数组中的数据大小 > 阈值的时候对当前的Table进行重新哈希 所以, 该HashMap是处理冲突检测的机制是向后移位, 清除过期条目 最终找到合适的位置;

了解完Set方法, 后面就是Get方法了:

```java
private Entry getEntry(ThreadLocal<?> key) {
    int i = key.threadLocalHashCode & (table.length - 1);
    Entry e = table[i];
    if (e != null && e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}
```

先找到ThreadLocal的索引位置, 如果索引位置处的entry不为空并且键与threadLocal是同一个对象, 则直接返回; 否则去后面的索引位置继续查找。



### ThreadLocal造成内存泄露的问题

网上有这样一个例子：

```java
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadLocalDemo {
    static class LocalVariable {
        private Long[] a = new Long[1024 * 1024];
    }

    // (1)
    final static ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES,
            new LinkedBlockingQueue<>());
    // (2)
    final static ThreadLocal<LocalVariable> localVariable = new ThreadLocal<LocalVariable>();

    public static void main(String[] args) throws InterruptedException {
        // (3)
        Thread.sleep(5000 * 4);
        for (int i = 0; i < 50; ++i) {
            poolExecutor.execute(new Runnable() {
                public void run() {
                    // (4)
                    localVariable.set(new LocalVariable());
                    // (5)
                    System.out.println("use local varaible" + localVariable.get());
                    localVariable.remove();
                }
            });
        }
        // (6)
        System.out.println("pool execute over");
    }
}  
```

如果用线程池来操作ThreadLocal 对象确实会造成内存泄露, 因为对于线程池里面不会销毁的线程, 里面总会存在着`<ThreadLocal, LocalVariable>`的强引用, 因为final static 修饰的 ThreadLocal 并不会释放, 而ThreadLocalMap 对于 Key 虽然是弱引用, 但是强引用不会释放, 弱引用当然也会一直有值, 同时创建的LocalVariable对象也不会释放, 就造成了内存泄露; 如果LocalVariable对象不是一个大对象的话, 其实泄露的并不严重, `泄露的内存 = 核心线程数 * LocalVariable`对象的大小;

所以, 为了避免出现内存泄露的情况, ThreadLocal提供了一个清除线程中对象的方法, 即 remove, 其实内部实现就是调用 ThreadLocalMap 的remove方法:

```java
private void remove(ThreadLocal<?> key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);
    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear();
            expungeStaleEntry(i);
            return;
        }
    }
}
```

找到Key对应的Entry, 并且清除Entry的Key(ThreadLocal)置空, 随后清除过期的Entry即可避免内存泄露。



### 再看ThreadLocal应用场景

除了上述的数据库管理类的例子，我们再看看其它一些应用：

#### 每个线程维护了一个“序列号”

> 再回想上文说的，如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal 实例。

每个线程维护了一个“序列号”

```java
public class SerialNum {
    // The next serial number to be assigned
    private static int nextSerialNum = 0;

    private static ThreadLocal serialNum = new ThreadLocal() {
        protected synchronized Object initialValue() {
            return new Integer(nextSerialNum++);
        }
    };

    public static int get() {
        return ((Integer) (serialNum.get())).intValue();
    }
}
```

### Session的管理

经典的另外一个例子：

```java
private static final ThreadLocal threadSession = new ThreadLocal();  
  
public static Session getSession() throws InfrastructureException {  
    Session s = (Session) threadSession.get();  
    try {  
        if (s == null) {  
            s = getSessionFactory().openSession();  
            threadSession.set(s);  
        }  
    } catch (HibernateException ex) {  
        throw new InfrastructureException(ex);  
    }  
    return s;  
}  
```

### 在线程内部创建ThreadLocal

还有一种用法是在线程类内部创建ThreadLocal，基本步骤如下：

- 在多线程的类(如ThreadDemo类)中，创建一个ThreadLocal对象threadXxx，用来保存线程间需要隔离处理的对象xxx。
- 在ThreadDemo类中，创建一个获取要隔离访问的数据的方法getXxx()，在方法中判断，若ThreadLocal对象为null时候，应该new()一个隔离访问类型的对象，并强制转换为要应用的类型。
- 在ThreadDemo类的run()方法中，通过调用getXxx()方法获取要操作的数据，这样可以保证每个线程对应一个数据对象，在任何时刻都操作的是这个对象。

```java
package com.vchicken.thread;

import java.util.Random;

/**
 * @Description ThreadLocalTest
 * @Author vchicken
 * @Date 2022/9/3 11:51
 */
public class ThreadLocalTest implements Runnable {

    ThreadLocal<Student> StudentThreadLocal = new ThreadLocal<Student>();

    @Override
    public void run() {
        String currentThreadName = Thread.currentThread().getName();
        System.out.println(currentThreadName + " is running...");
        Random random = new Random();
        int age = random.nextInt(100);
        System.out.println(currentThreadName + " is set age: "  + age);
        Student Student = getStudent(); //通过这个方法，为每个线程都独立的new一个Student对象，每个线程的的Student对象都可以设置不同的值
        Student.setAge(age);
        System.out.println(currentThreadName + " is first get age: " + Student.getAge());
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println( currentThreadName + " is second get age: " + Student.getAge());

    }

    private Student getStudent() {
        Student Student = StudentThreadLocal.get();
        if (null == Student) {
            Student = new Student();
            StudentThreadLocal.set(Student);
        }
        return Student;
    }

    public static void main(String[] args) {
        ThreadLocalTest t = new ThreadLocalTest();
        Thread t1 = new Thread(t,"Thread A");
        Thread t2 = new Thread(t,"Thread B");
        t1.start();
        t2.start();
    }
}


class Student{
    int age;
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }

}
```

```java
//运行结果，可以看到多线程之间student对象的属性都是独立的。
Thread A is running...
Thread B is running...
Thread A is set age: 92
Thread B is set age: 51
Thread A is first get age: 92
Thread B is first get age: 51
Thread A is second get age: 92
Thread B is second get age: 51
```

### java 开发手册中推荐的 ThreadLocal

看看阿里巴巴 java 开发手册中推荐的 ThreadLocal 的用法:

```java
import java.text.DateFormat;
import java.text.SimpleDateFormat;
 
public class DateUtils {
    public static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>(){
        @Override
        protected DateFormat initialValue() {
            return new SimpleDateFormat("yyyy-MM-dd");
        }
    };
}
```

然后我们再要用到 DateFormat 对象的地方，这样调用：

```java
DateUtils.df.get().format(new Date());
```

### 课后提问

OK，`ThreadLocal`的学习到这里基本结束了，检验一下自己的学习效果吧，最后一排的同学起来回答一下以下问题：

- 什么是ThreadLocal? 用来解决什么问题的?

- 说说你对ThreadLocal的理解

- ThreadLocal是如何实现线程隔离的?

- 为什么ThreadLocal会造成内存泄露? 如何解决

- 还有哪些使用ThreadLocal的应用场景?



## **关键字—final详解**

## **关键字—synchronized详解**

## **JUC—结构说明**

## **JUC原子类—CAS,Unsafe和原子类详解**

## **JUC锁—ReentrantLock等详解**

## **JUC集合—ConcurrentHashMap等详解**

## **JUC线程池—FutureTask等详解**

## **JUC工具类—CountDownLatch等详解**



## 参考文章

- [Java 全栈知识体系](https://www.pdai.tech/md/java/thread/java-thread-x-overview.html)
- [CS-Notes](http://www.cyc2018.xyz/Java/Java%20%E5%B9%B6%E5%8F%91.html)

