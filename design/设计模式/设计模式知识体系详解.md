**<span style="font-size: 35px;">👼 设计模式知识体系详解</span>**

---

# 知识体系

> [!TIP]
>
> 待补充，这里先附上@pdai大佬制作的结构图,后续再自己制作知识体系图

![设计模式知识体系](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-09-18/73922b11-15a1-478b-86ab-ba821b845798_design-pattern.png)

# 概述

`设计模式`，即`Design Patterns`，是指在软件设计中，被反复使用的一种**代码设计经验**。使用设计模式的目的是**为了可重用代码，提高代码的可扩展性和可维护**性。

`设计模式`这个术语是上个世纪90年代由`Erich Gamma`、`Richard Helm`、`Raplh Johnson`和`Jonhn Vlissides`四个人总结提炼出来的，并且写了一本[Design Patterns](https://en.wikipedia.org/wiki/Design_Patterns)的书。这四人也被称为`四人帮（GoF）`。

为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，因此它还基于[面向对象七大设计原则](design/设计模式/面向对象七大设计原则)。

设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF把23个常用模式分为`创建型模式`、`结构型模式`和`行为型模式`三类，我们将在后续的文章中分别详细介绍各种设计模式。

!> 学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计的复杂度和灵活性，并意识到设计模式也并不是万能的。



# 设计模式简介

根据**用途**来分，设计模式可分为：

- 创建型(`Creational`)：主要用于描述如何创建对象
- 结构型(`Structural`)：主要用于描述如何实现类或对象的组合
- 行为型(`Behavioral`)：主要用于描述类或对象怎样交互以及怎样分配职责

## 创建型设计模式

> [!NOTE]
>
> **创建型设计模式** ：对类的实例化过程进行了抽象，能够将软件模块中**对象的创建**和对象的使用分离。

|                         设计模式名称                         |                             概述                             | 使用频率 |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :------: |
|   [单例模式(Singleton Pattern)](design/设计模式/单例模式)    | 确保某一个类只有一个实例，而且自己实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 |  ★★★★☆   |
| [简单工厂模式(Simple Factory Pattern)](design/设计模式/工厂模式三兄弟?id=简单工厂模式) | 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式 |  ★★★☆☆   |
| [工厂方法模式(Factory Method Pattern)](design/设计模式/工厂模式三兄弟?id工厂方法模式) | 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。 |  ★★★★★   |
| [抽象工厂模式(Abstract Factory Pattern)](design/设计模式/工厂模式三兄弟?id=抽象工厂模式) | 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 |  ★★★★★   |
|   [原型模式(Prototype Pattern)](design/设计模式/原型模式)    | 使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 |  ★★★☆☆   |
|  [建造者模式(Builder Pattern)](design/设计模式/建造者模式)   | 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 |  ★★☆☆☆   |

!> 记忆口诀：创工原单建抽（创公园，但见愁）



## 结构型设计模式

> [!NOTE]
>
> **结构型设计模式** ：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像**搭积木**，可以通过简单积木的组合形成复杂的、功能更为强大的结构。

|                       设计模式名称                        |                             概述                             | 使用频率 |
| :-------------------------------------------------------: | :----------------------------------------------------------: | :------: |
| [适配器模式(Adapter Pattern)](design/设计模式/适配器模式) | 将一个接口转换成期望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(`Wrapper`)。 |  ★★★★☆   |
|   [桥接模式(Bridge Pattern)](design/设计模式/桥接模式)    |    将抽象部分与它的实现部分分离，使它们都可以独立地变化。    |  ★★★☆☆   |
|  [组合模式(Composite Pattern)](design/设计模式/组合模式)  | 组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。 |  ★★★★☆   |
|  [装饰模式(Decorator Pattern)](design/设计模式/装饰模式)  | 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。 |  ★★★☆☆   |
|   [外观模式(Facade Pattern)](design/设计模式/外观模式)    | 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 |  ★★★★★   |
|  [享元模式(Flyweight Pattern)](design/设计模式/享元模式)  | 运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。 |  ★☆☆☆☆   |
|    [代理模式(Proxy Pattern)](design/设计模式/代理模式)    | 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 |  ★★★★☆   |

!> 记忆口诀：结享外组适代装桥（姐想外租，世代装桥）

## 行为型设计模式

> [!NOTE]
>
> **行为型设计模式** ：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的**相互作用**。

|                           模式名称                           |                             概述                             | 使用频率 |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :------: |
| [职责链模式(Chain of Responsibility Pattern)](design/设计模式/职责链模式) | 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 |  ★★☆☆☆   |
|    [命令模式(Command Pattern)](design/设计模式/命令模式)     | 将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 |  ★★★★☆   |
| [解释器模式(Interpreter Pattern)](design/设计模式/解释器模式) | 定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。 |  ★☆☆☆☆   |
|  [迭代器模式(Iterator Pattern)](design/设计模式/迭代器模式)  |  提供一种方法来访问聚合对象，而不用暴露这个对象的内部存储。  |  ★★★★★   |
|  [中介者模式(Mediator Pattern)](design/设计模式/中介者模式)  | 用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 |  ★★☆☆☆   |
|  [备忘录模式(Memento Pattern)](design/设计模式/备忘录模式)   | 当你需要让对象返回之前的状态时(例如, 你的用户请求"撤销"), 你使用备忘录模式 |  ★★☆☆☆   |
|  [观察者模式(Observer Pattern)](design/设计模式/观察者模式)  | 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新 |  ★★★★★   |
|  [访问者模式(visitor pattern)](design/设计模式/访问者模式)   | 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式 |  ★★★☆☆   |
|     [状态模式(State Pattern)](design/设计模式/状态模式)      | 允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类 |  ★★★★☆   |
|    [策略模式(Strategy Pattern)](design/设计模式/策略模式)    | 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户 |  ★★★☆☆   |
| [模板方法模式(Template Method Pattern)](design/设计模式/模板方法模式) | 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤 |  ★☆☆☆☆   |

!> 记忆口诀：行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）