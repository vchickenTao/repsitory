### 1.面向对象
**1.什么是面向对象？**
说到面向对象，那么我们就不得不先提到面向过程，例如我们学过的最基础的变成的语言——`C语言`，就是一种面向过程的语言。那么面向对象和面向过程有什么区别呢？

- `面向过程`是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。
   ```java
例如：一个事情，妈妈叫孩子起床吃饭，那么按照面向过程的思想，那我们需要至少按照以下步骤进行：
      1.妈妈先起床；
      2.妈妈洗漱；
      3.妈妈准备早餐；
      4.叫孩子起床；
      5.孩子起床；
      6.孩子洗漱；
      7.孩子吃饭。
   ```
- `面向对象`是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。
  ```java
    同样的事情，只需要一个步骤：
    妈妈叫孩子吃饭
    其中，妈妈需要做的事情都在妈妈对象中，孩子需要做的事情都在孩子对象中。
  ```
- 面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。

**2.面向对象和面向过程的优缺点**

**1. 面向过程：**
   - **优点**：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
   - **缺点：**没有面向对象易维护、易复用、易扩展。

**2. 面向对象：**
   - **优点**：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。
   - **缺点：**性能比面向过程低。

**3.面向对象的特性**
- **封装**： 封装的意义，在于明确标识出允许外部使用属性和方法，内部细节对外部调用透明，外部调用无需修改或者关心内部的实现。
  - javabean的属性私有，只提供get和set供外部调用，属性的赋值和逻辑只能由javabean自身决定，不能由外部胡乱修改；
  - ORM框架，例如mybatis，操作数据库，我们不需要关心链接是怎么建立的/sql是怎么执行的，只需要引入mybatis，调用方法即可。

- **继承**： 继承基类的方法，并做出自己的改变或者拓展。子类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

- **多态**：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。
  1. java如何实现多态？
    - 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用**在编译时并不确定**，而是**在程序运行期间才确定**，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，**不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上**，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。
    - 多态分为`编译时多态`和`运行时多态`。其中编译时多态是**静态**的，主要是指**方法的重载**，它是根据**参数列表的不同来区分不同的函数**，通过编译之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是**动态**的，它是通过动态绑定来实现的，也就是我们所说的多态性。
  2.多态的实现
    - 多态的实现要满足三个条件：
      1.继承
      2.重写
      3.向上转型（父类引用指向子类对象）
```java
父类类型 变量名 = new 子类对象；
变量名.子类方法名()；
无法调用子类中的特有方法，即父类中没有的方法，可以理解为为满足重写条件
```

**4.面向对象的七大原则**
**一 开闭原则(The Open-Closed Principle ，OCP)**
**开闭原则**：软件实体应当对扩展开放，对修改关闭。
根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。
- **扩展开放**：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。
- **修改关闭**：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求模块是修改关闭的。

**二 单一职责原则（Single Responsibility Principle，SRP）**
单一职责原则是最简单的面向对象设计原则，它用于`控制类的粒度大小`，将对象解耦，提高内聚性。
单一职责原则：**一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中**。
该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：
- 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
- 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

**三 里氏替换原则（Liskov Substitution Principle ，LSP）**
**里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象**
符合条件：

 1. 不应该在代码中出现if/else之类对派生类类型进行判断的条件。
 2. 派生类应当可以替换基类并出现在基类能够出现的任何地方

**四 迪米特原则（最少知道原则）（Law of Demeter ，LoD）**
**第米特原则：talk only to your immediate friends，只与你直接的朋友们通信，不要跟“陌生人”说话。**
一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
迪米特法则中的“朋友”是指：**当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等**，这些对象同当前对象存在`关联、聚合或组合关系`，可以直接访问这些对象的方法。

**五 接口隔离原则(Interface Segregation Principle, ISP)**
**接口隔离原则：**使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。(要为各个类建立它们需要的专用接口)

**六 依赖倒置原则（Dependency Inversion Principle ，DIP）**
**依赖倒置原则：**高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。（面向接口/抽象编程，不要面向实现（实现类）编程）

**七 合成复用原则（Composite/Aggregate Reuse Principle ，CARP）**
**合成复用原则：**尽量使用对象组合或者聚合等关联关系，而不是继承来达到复用的目的。

### 2.JDK和JRE和JVM的区别
1.`JDK(Java Development Kit)`是java开发工具包，JDK包括JRE，类库，java工具,所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等。
2.`JRE(Java Runtime Environment)`是java运行时环境，包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等。
3.JVM（Java Virtual Machine）是Java虚拟机。在倒数第二层 由他可以在（最后一层的）各种平台上运行 Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。
![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-15/30239126-8e3d-43b5-b7d3-c06be44c4ea7.png)


### 3.hashCode()与equals()之间的关系

**1.hashCode：**
`hashCode`方法返回对象的散列码，返回值是 int 类型的散列码。散列码的作用是确定该对象在哈希表中的索引位置。
**关于 hashCode 有一些约定：**
- 两个对象相等，则 hashCode 一定相同；
- 两个对象有相同的 hashCode 值，它们不一定相等；
- hashCode()方法默认是对堆上的对象产生独特值，如果没有重写 hashCode()方法，则该类的两个对象的 hashCode值肯定不同。

**2.equals**
```java
  //String类中的equals()方法
  public boolean equals(Object anObject) {
        if (this == anObject) {
            //判断引用地址是否相同
            return true;
       }
        if (anObject instanceof String) {
            //对象类型是否相同
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        //对象的值是否相同
                        return false;
                    i++;
               }
                return true;
           }
       }
        return false;
   }

```
**从源码中可以看到：**
- equals方法首先比较的是**内存地址**，如果内存地址相同，直接返回 true；如果内存地址不同，再比较**对象的类型**，类型不同直接返回 false；类型相同，再比较**值**是否相同；值相同返回 true，值不同返回 false。总结一下，equals会比较**内存地址、对象类型、以及值**，内存地址相同， equals一定返回 true；对象类型和值相同，equals 方法一定返回true。
- 如果没有重写 equals 方法，那么 equals 和 == 的作用相同，比较的是对象的地址值。

**3.== 和 equals 的区别是什么？**
- **==**: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是**值**，引用数据类型 == 比较的是**内存（引用）地址**)。
- **equals()**: 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
  - 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
  - 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

### 4.泛型中extends和super的区别
1.`<? extends T>`表示包括T在内的任何T的子类
2.`<? super T>`表示包括T在内的任何T的父类

### 5.重载和重写的区别

- 方法的`重载`和`重写`都是实现`多态`的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
- 发生在**同一个类**中，**方法名必须相同**，**参数列表不同（参数类型不同、个数不同、顺序不同）**，**与方法返回值和访问修饰符无关**，即重载的方法不能根据返回类型进行区分。
- 发生在**父子类**中，**方法名、参数列表必须相同**，**返回值范围小于等于父类**，**抛出的异常小于等于父类**，**访问修饰符大于等于父类（里氏代换原则）**；如果父类方法访问修饰符为private则子类中就不是重写，即**两同两小一大原则**。

### 6.List，Set，Map三者的区别
![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-15/93333f7e-7fbc-4393-8246-9cdbf887f757.png)
![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-15/a5fe36e0-e61f-4348-93ee-06793db30786.png)

- Java容器分为Collection和Map两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口；
- **Collection集合**主要有`List`和`Set`两大接口：
  - **List**：一个**有序**（元素存入集合的顺序和取出的顺序一致）容器，**元素可以重复**，**可以插入多个null元素**，元素都有索引。常用的实现类有 `ArrayList`、`LinkedList` 和 `Vector`;
  - **Set**：一个**无序**（存入和取出顺序有可能不一致，TreeSet例外，它是有序的）容器，**不可以存储重复元素**，**只允许存入一个null元素**，必须保证元素唯一性。Set 接口常用实现类是 `HashSet`、`LinkedHashSet` 以及`TreeSet`。
- **Map**是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象
  - Map的常用实现类：`HashMap`、`TreeMap`、`HashTable`、`LinkedHashMap`、`ConcurrentHashMap`。

### 7.集合框架底层数据结构
- **Collection**
  - **List**
    1. **Arraylist**： Object数组
    2. **Vector**： Object数组
    3. **LinkedList**： 双向循环链表
- **Set**
  - **HashSet（无序，唯一）**：基于HashMap 实现的，底层采用 HashMap来保存元素
  - **LinkedHashSet**： LinkedHashSet继承自HashSet，并且其内部是通过LinkedHashMap来实现的。有点类似于我们之前说的LinkedHashMap其内部是基于HashMap实现一样，不过还是有一点点区别的
  - **TreeSet（有序，唯一）**： 红黑树(自平衡的排序二叉树。)
- **Map**
  - **HashMap**： JDK1.8之前HashMap由**数组+链表**组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，**当链表长度大于阈值（默认为8）时，将链表转化为红黑树**，以减少搜索时间
  - **LinkedHashMap**：LinkedHashMap继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，**增加了一条双向链表**，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑
  - **HashTable**： **数组+链表**组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的
  - **TreeMap**： 红黑树（自平衡的排序二叉树）

### 8.哪些集合类是线程安全的？
- **Vector**：就比Arraylist多了个 synchronized （线程安全），因为效率较低，现在已经不太建议使用
- **HashTable**：就比hashMap多了个synchronized (线程安全)，不建议使用
- **ConcurrentHashMap**：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）

### 9.Java集合的快速失败机制 “fail-fast”
<a herf="https://blog.csdn.net/qq_45649807/article/details/126211551">Java集合的快速失败机制</a>

### 10.ArrayList和LinkedList的区别

- 首先，他们的底层数据结构不同，前者是基于数组实现的，后者是基于链表实现的；
- 由于底层数据结构不同，他们所适用的场景也不同，前者适合随机查找，后者则更适合删除和添加，查询/添加/删除的时间复杂度不同；
- 另外两者都实现了List接口，但是后者还额外实现了Deque接口，所以后者还可以当做队列来使用。

### 11.谈谈ConcurrentHashMap的扩容机制

- **JDK1.7**：
  1. 1.7版本的ConcurrentHashMap是基于Segment分段实现的
  2. 每个Segment相对于⼀个⼩型的HashMap
  3. 每个Segment内部会进⾏扩容，和HashMap的扩容逻辑类似
  4. 先⽣成新的数组，然后转移元素到新数组中
  5. 扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值
- **JDK1.8**：
  1. 1.8版本的ConcurrentHashMap不再基于Segment实现
  2. 当某个线程进⾏put时，如果发现ConcurrentHashMap正在进⾏扩容那么该线程⼀起进⾏扩容
  3. 如果某个线程put时，发现没有正在进⾏扩容，则将key-value添加到ConcurrentHashMap中，然 后判断是否超过阈值，超过了则进⾏扩容
  4. ConcurrentHashMap是⽀持多个线程同时扩容的
  5. 扩容之前也先⽣成⼀个新的数组
  6. 在转移元素时，先将原数组分组，将每组分给不同的线程来进⾏元素的转移，每个线程负责⼀组或 多组的元素转移⼯作

### 12.HashMap的扩容机制原理

- **JDK1.7版本**
  1. 先⽣成新数组
  2. 遍历老数组中的每个位置上的链表上的每个元素
  3. 取每个元素的key，并基于新数组⻓度，计算出每个元素在新数组中的  下标
  4. 将元素添加到新数组中去
  5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

- **JDK1.8版本**
  1. 先生成新数组
  2. 遍历老数组中的每个位置上的链表或红⿊树
  3. 如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去
  4. 如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置
      a. 统计每个下标位置的元素个数
      b. 如果该位置下的元素个数超过了8，则⽣成⼀个新的红黑树，并将根节点的添加到新数组的对应位置
      c. 如果该位置下的元素个数没有超过8，那么则⽣成⼀个链表，并将链表的头节点添加到新数组的对应位置
  5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

### 13.JDK1.7到JDK1.8 HashMap发生了说明变化？

- 1.7版本底层数据结构是**数组+链表**，1.8之后底层变为**数组+链表+红黑树**，加入红黑树整体提高了hashmap**插入和查询效率**。
- 1.7链表结构中插入采用的是**头插法**，1.8之后插入采用**尾插法**，因为jdk1.8种插入元素需要遍历整个链表统计元素个数，所以正好采用尾插法。
- 1.7种哈希算法比较复杂，存在各种右移异或运算，1.8中进行的简化，复杂哈希算法是为了提高散列性，来提升hashmap整体效率，1.8中加入了红黑树，所以可以适当简化哈希算法，节省cpu利用率。
![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-16/c6da9782-2478-4c9c-a633-207cd5f044f6.png)

### 14.CopyOnWriteArrayList的底层原理是怎样的

1、⾸先CopyOnWriteArrayList内部也是⽤过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制⼀个新的数组，写操作在新数组上进行，读操作在原数组上进⾏
2、并且，写操作会加锁，防止出现并发写入丢失数据的问题
3、写操作结束之后会把原数组指向新数组
CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很高的场景。

### 15.深拷贝和浅拷贝的区别

`深拷贝`和`浅拷贝`就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。

1. 浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象
2. 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象

### 16.什么是字节码？采用字节码的最大好处是什么？

- **字节码**：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机，可以做到一次编译到处运行。
- **采用字节码的好处**：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，编译器在编译源代码时可以做一些编译期的优化，比如`锁消除`，`标量替换`，`方法内联`等。同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行，实现了跨平台。
- **先看下java中的编译器和解释器**：Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行。

### 17.Java中的异常体系是怎样的

![](https://vue-admin-imgages.oss-cn-hangzhou.aliyuncs.com/2022-08-17/4023279a-5735-4759-8068-4d2e7ee2e381.png)

1. `Thorwable`类（表示可抛出）是所有异常和错误的超类，两个直接子类为`Error`和`Exception`，分别表示**错误**和**异常**。
2. 其中异常类Exception又分为**运行时异常**(RuntimeException)和**非运行时异常**， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。
3. **Error错误:** 描述了Java运行时系统的内部错误和资源耗尽错误。一般是指虚拟机（JVM）相关的问题，如系统崩溃，虚拟机出错误等，这种错误无法恢复或不可能捕获，将导致应用程序中断，通常不处理。因为如果出现这样的内部错误，除了通告用户，并尽力使程序安全地终止之外，再也无能为力了。
4. **Exception异常：** Java的异常分为两种，checked Exception（编译时异常也叫非运行时异常）和 RuntimeException（运行时异常）。这种异常是可以靠程序自己来解决的，我们可以选择捕获这些异常做特殊处理。
5. **运行时异常**（逻辑方面）都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是**非检查异常**，程序中可以选择捕获处理，也可以不处理。这些异常一般是由**程序逻辑错误**引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
6. **非运行时异常**（程序语法）是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，**如果不处理，程序就不能编译通过**。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。