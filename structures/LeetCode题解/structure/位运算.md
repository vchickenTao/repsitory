# 🐀 位运算

---

## Java中支持的7种位运算

`与（&）`：二元运算符，**两个为1时结果为1，否则为0**;

`或（|）`：二元运算符，**两个其中有一个为1时结果就为1，否则为0**;

`异或（^）`：二元运算符，**两个数同时为1或0时结果为0，否则为1**;

`取非（~）`：一元运算符，**取反操作**;

`左移（<<）`：二元运算符，**按位左移一定的位置。高位溢出，低位补符号位，符号位不变**;

`右移（>>）`：二元运算符，**按位右移一定的位置。高位补符号位，符号位不变，低位溢出**;

`无符号右移（>>>）`：二元运算符，**符号位（即最高位）保留，其它位置向右移动，高位补零，低位溢出**。



## 位运算符详解

### 1、左移( << )

> 符号位不变，低位补0。移几位补几个0。正数或者负数左移，低位都是用0补。

案例：将5左移2位

```java
public class Test {
	public static void main(String[] args) {
		System.out.println(5<<2);//运行结果是20
	}
}
```

!> 运行结果是20，但是程序是怎样执行的呢？

首先会将5转为2进制表示形式(java中，整数默认就是int类型,也就是32位):

0000 0000 0000 0000 0000 0000 0000 0101           然后左移2位后，低位补0：

0000 0000 0000 0000 0000 0000 0001 01**00**           换算成10进制为20

### 2、右移( >> ) 

> 如果值为正，则在高位补0，如果值为负，则在高位补1.

```java
System.out.println(5>>2);//运行结果是1
```

还是先将5转为2进制表示形式：

0000 0000 0000 0000 0000 0000 0000 0101 

然后右移2位，高位补0：

**00**00 0000 0000 0000 0000 0000 0000 0001

### 3、无符号右移( >>> )

> 无符号的意思是将符号位当作数字位看待。
> 即无论值的正负，都在高位补0.

我们知道在Java中int类型占32位，可以表示一个正数，也可以表示一个负数。正数换算成二进制后的最高位为0，负数的二进制最高位为1

例如  **-5**换算成二进制后为：

1111 1111 1111 1111 1111 1111 1111 1011   (刚开始接触二进制时，不知道最高位是用来表示正负之分的，当时就总想不通。。明明算起来得到的就是一个正数-_-)

我们分别对5进行右移3位、 -5进行右移3位和无符号右移3位：

```java
public class Test {
	public static void main(String[] args) {
		System.out.println(5>>3);//结果是0
		System.out.println(-5>>3);//结果是-1
		System.out.println(-5>>>3);//结果是536870911
	}
}
```


我们来看看它的移位过程(可以通过其结果换算成二进制进行对比)：

5换算成二进制： 0000 0000 0000 0000 0000 0000 0000 0101

5右移3位后结果为0，0的二进制为： **000**0 0000 0000 0000 0000 0000 0000 0000        // (**用0进行补位**)

 -5换算成二进制： 1111 1111 1111 1111 1111 1111 1111 1011

-5右移3位后结果为-1，-1的二进制为：  **111**1 1111 1111 1111 1111 1111 1111 1111   // (**用1进行补位**)

-5无符号右移3位后的结果 536870911 换算成二进制：  **000**1 1111 1111 1111 1111 1111 1111 1111   // (**用0进行补位**)


通过其结果转换成二进制后，我们可以发现，**正数右移，高位用0补，负数右移，高位用1补，当负数使用无符号右移时，用0进行部位(自然而然的，就由负数变成了正数了)**

**注意：笔者在这里说的是右移，高位补位的情况。正数或者负数左移，低位都是用0补。(自行测试)**



### 4、位与( & )

> 第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0

```java
public class Test {
	public static void main(String[] args) {
		System.out.println(5 & 3);//结果为1
	}
}
```

还是老套路，将2个操作数和结果都转换为二进制进行比较：

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101

3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011

-------------------------------------------------------------------------------------

1转换为二进制：0000 0000 0000 0000 0000 0000 0000 0001



### 5、位或( | )

> 第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0

```java
public class Test {
	public static void main(String[] args) {
		System.out.println(5 | 3);//结果为7
	}
}
```

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101

3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011

-------------------------------------------------------------------------------------

7转换为二进制：0000 0000 0000 0000 0000 0000 0000 0111



### 6、位异或( ^ )

> 第一个操作数的第n位与第二个操作数的第n位不同，结果为1，否则为0。

```java
public class Test {
	public static void main(String[] args) {
		System.out.println(5 ^ 3);//结果为6
	}
}
```

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101

3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011

-------------------------------------------------------------------------------------

6转换为二进制：0000 0000 0000 0000 0000 0000 0000 0110



7、位非( ~ ) 

> 操作数的第n位为1，那么结果的第n位为0，反之。

```java
public class Test {
	public static void main(String[] args) {
		System.out.println(~5);//结果为-6
	}
}
```

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101

-6转换为二进制：1111 1111 1111 1111 1111 1111 1111 1010





**由位运算操作符衍生而来的有：**

&= 按位与赋值

|= 按位或赋值

^= 按位非赋值

\>>= 右移赋值

\>>>= 无符号右移赋值

<<= 赋值左移

**和 += 一个概念而已。**

> 举个栗子：

```java
public class Test {
	public static void main(String[] args) {
		int a = 5
		a &= 3;
		System.out.println(a);//结果是1
	}
}
```



## 常见用法

### （1） 公式：`m*2^n = m << n`

练习：

```java
@Test
public void test() {
    System.out.println("2^3=" + (1 << 3));//2^3=8
    System.out.println("3*2^3=" + (3 << 3));//3*2^3=24
}
```
法则一：任何数左移（右移）32的倍数位等于该数本身。
法则二：在位移运算m<<n的计算中，若n为正数，则实际移动的位数为n%32，若n为负数，则实际移动的位数为(32+n%32)，右移，同理。
左移是乘以2的幂，对应着右移则是除以2的幂。

### （2）判断一个数n的奇偶性

n&1 == 1?”奇数”:”偶数”

为什么与1能判断奇偶？所谓的二进制就是满2进1，那么好了，偶数的最低位肯定是0（恰好满2，对不对？），同理，奇数的最低位肯定是1.int类型的1，前31位都是0，无论是1&0还是0&0结果都是0，那么有区别的就是1的最低位上的1了，若n的二进制最低位是1（奇数）与上1，结果为1，反则结果为0.
练习：

```java
@Test
public void test() {
    int n = 2;
    int m = 3;
    System.out.println((n & 1) == 1 ? "奇数" : "偶数"); //偶数
    System.out.println((m & 1) == 1 ? "奇数" : "偶数"); //奇数
}
```


### （3）不用临时变量交换两个数

这个知识点面试的时候有可能会被问到
在int[]数组转置的过程中，是不是看到过这样的代码：

```java
public static int[] reverse(int[] nums){
	int i = 0;
	int j = nums.length-1;
	while(j>i){
		nums[i]= nums[i]^nums[j];
		nums[j] = nums[j]^nums[i];
		nums[i] = nums[i]^nums[j];
		j--;
		i++;
	}
	return nums;
}
```

连续三次使用异或，并没有临时变量就完成了两个数字交换，怎么实现的呢？
解释：

```java
public void test2() {
    int n = 2;
    int m = 3;
    n = n ^ m;
    m = m ^ n;  //m = m ^ (n ^ m) => m=n
    n = n ^ m;  //n = (n ^ m)^[m ^ (n ^ m)] => n=m
    System.out.println(n + ";" + m); //3;2
}
```
常见的计算法则：
① a ^ a =0 （任何数异或本身结果为0）
② a ^ b =b ^ a （交换律）
③ a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c （结合律）
④ 0 ^ a = a （异或0具有保持的特点）
⑤ a ^ b ^ a = b （根据①②④可得）

### （4）取绝对值

公式：` |a| = (a^(a>>31))-(a>>31)`

先整理一下使用位运算取绝对值的思路：若a为正数，则不变，需要用异或0保持的特点；若a为负数，则其补码为源码翻转每一位后+1，先求其源码，补码-1后再翻转每一位，此时需要使用异或1具有翻转的特点。

任何正数右移31后只剩符号位0，最终结果为0，任何负数右移31后也只剩符号位1，溢出的31位截断，空出的31位补符号位1，最终结果为-1.右移31操作可以取得任何整数的符号位。

那么综合上面的步骤，可得到公式。a>>31取得a的符号，若a为正数，a>>31等于0，a^0=a，不变；若a为负数,a>>31等于-1 ，a^-1翻转每一位。

练习：

```java
public void test1() {
    int a = -10;
    System.out.println((a ^ (a >> 31)) - (a >> 31)); //10
}
```


## 有趣的位运算符操作

### 1.利用或操作 | 和空格将英文字符转换为小写

```java
('a' | ' ') = 'a'
('A' | ' ') = 'a'
```

### 2.利用与操作 & 和下划线将英文字符转换为大写

```java
('b' & '_') = 'B'
('B' & '_') = 'B'
```

### 3.利用异或操作 ^ 和空格进行英文字符大小写互换

```java
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'
```


以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。

### 4.判断两个数是否异号

```java
int x = -1, y = 2;
bool f = ((x ^ y) < 0); // true

int x = 3, y = 2;
bool f = ((x ^ y) < 0); // false
```


这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。

### 5.不用临时变量交换两个数

```java
int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b;
// 现在 a = 2, b = 1
```

### 6.加一

```java
int n = 1;
n = -~n;
```

### 7.减一

```java
int n = 2;
n = ~-n;
```



## 参考文章

- [Java 位运算(移位、位与、或、异或、非）](https://blog.csdn.net/xiaochunyong/article/details/7748713)
- [一篇搞定位运算——java位运算详解](https://blog.csdn.net/qq_42265220/article/details/118386893?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-118386893-blog-123000487.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-118386893-blog-123000487.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1)

